///*探究缓冲区下的scanf
//1. 缓冲区:缓冲区是为了缓解用户输入和系统处理的(因为用户输入,操作系统会调用相应的硬件来处理,加缓存区可以减少调用
//   次数,提高效率),也是缓解外存和内存速度不匹配问题
//2. 在windows系统中,一般的输出函数都是没有缓存区的,而输入函数配备了缓冲区*/
//#include <stdio.h>
//
//int main()
//{
//	/*探究缓存区给scanf带来的问题*/
//
//	/*缓存区有三种:1. 行缓存(遇到换行符刷新缓存区:输入函数一般是行缓存)
//	               2. 完全缓存(缓存区满刷新缓存区:给文件中输入一般是完全缓存)
//				   3. 无缓存(没有缓存区)*/
//
//	/*scanf的读取原理:
//	  1) 当用户输入的时候,按下ENTER数据(包括换行符)被存入缓存区
//	  2) scanf配备的是行缓存区
//	  3) 当用户按下ENTER的时候,scanf从缓存区中读取数据
//	  4）首先,scanf会检测缓存区有没有数据,如果没有数据,scanf会等待用户输入
//
//	     如果,缓存区中有数据,scanf会读取数据与自己的控制字符相匹配,1.如果相符合就读取,位置指针(scanf的缓存区中有
//		 一个位置指针,用于指定读取到那一块了),2.如果没有匹配成功,scanf会尝试忽略掉空白字符,如果忽略掉后依然无法
//		 匹配,那么当前的控制字符读取失败
//
//	  5）如果缓存区的数据(除空白字符之外)少于scanf的控制字符(都匹配的情况下),scanf会先读取有的数据,然会会等待用
//	     户输入*/
//
//
//	/*scanf读取问题1:在什么时候scanf可以跳过空白字符
//	       1) 当scanf的控制字符,只有%d,%c,%f等的时候,scanf会跳过空白符,读取相应的数据
//		   2）但是如果控制字符还有其它的规定,那么就不会跳过空白字符,空白字符会参加对比,如果不相同,直接读取失败
//		      (例如:scanf("[%d]",a)),像这种就是,双引号内不是单纯的控制字符*/
//
//	/*测试*/
//	int a, b;
//
//	scanf("%d", &a);
//	scanf("+%d", &b);   /*当输入一个值时,直接就读取失败了,就是因为双引号内部,不是简单的控制字符*/
//
//	scanf("%d", &a);
//	scanf("%d", &b);  /*当输入一个值是,会再次等待你输入下一个值,因为此是scanf中使用的只是控制字符*/
//}